name: Claude AI Code Generation

on:
  issues:
    types: [opened, edited]
  issue_comment:
    types: [created]
  workflow_dispatch:
    inputs:
      task_description:
        description: 'Describe the code generation task'
        required: true
        type: string
      target_branch:
        description: 'Target branch for the generated code'
        required: false
        default: 'claude-generated'
        type: string

jobs:
  generate-code:
    runs-on: ubuntu-latest
    if: |
      (github.event_name == 'issues' && contains(github.event.issue.labels.*.name, 'claude-generate')) ||
      (github.event_name == 'issue_comment' && contains(github.event.comment.body, '/claude generate')) ||
      (github.event_name == 'workflow_dispatch')
    
    permissions:
      contents: write
      pull-requests: write
      issues: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'

      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'

      - name: Install dependencies
        run: |
          npm install --legacy-peer-deps
          pip install boto3 requests botocore

      - name: Extract task description
        id: task
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            echo "description=${{ github.event.inputs.task_description }}" >> $GITHUB_OUTPUT
            echo "branch=${{ github.event.inputs.target_branch }}" >> $GITHUB_OUTPUT
          elif [ "${{ github.event_name }}" = "issues" ]; then
            # Extract task from issue body
            echo "description<<EOF" >> $GITHUB_OUTPUT
            echo "${{ github.event.issue.body }}" >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
            echo "branch=claude-generated-issue-${{ github.event.issue.number }}" >> $GITHUB_OUTPUT
          else
            # Extract task from comment
            COMMENT_BODY="${{ github.event.comment.body }}"
            TASK_DESC=$(echo "$COMMENT_BODY" | sed -n 's|^/claude generate \(.*\)|\1|p')
            echo "description=$TASK_DESC" >> $GITHUB_OUTPUT
            echo "branch=claude-generated-comment-${{ github.event.comment.id }}" >> $GITHUB_OUTPUT
          fi

      - name: Analyze codebase structure
        run: |
          find . -type f \( -name "*.ts" -o -name "*.tsx" -o -name "*.js" -o -name "*.jsx" \) \
            -not -path "./node_modules/*" \
            -not -path "./.git/*" > codebase_files.txt
          
          echo "Project structure:" > project_context.txt
          tree -I 'node_modules|.git' -L 3 >> project_context.txt || ls -la >> project_context.txt
          
          echo "Package.json content:" >> project_context.txt
          cat package.json >> project_context.txt

      - name: Generate code with Claude
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          AWS_BEDROCK_MODEL_ID: ${{ secrets.AWS_BEDROCK_MODEL_ID }}
          TASK_DESCRIPTION: ${{ steps.task.outputs.description }}
          TARGET_BRANCH: ${{ steps.task.outputs.branch }}
        run: |
          cat << 'EOF' > claude_generator.py
          import boto3
          import json
          import os
          import requests
          import subprocess
          import tempfile
          from botocore.config import Config
          
          
          def get_bedrock_client():
            config = Config(
                read_timeout=120,  # Increase from default (~60s)
                connect_timeout=10,  # Optional, you can tweak this too
                retries={
                    'max_attempts': 3,
                    'mode': 'standard'
                }
            )
            return boto3.client('bedrock-runtime', region_name=os.environ['AWS_DEFAULT_REGION'], config=config)
          
          def read_file_safely(filepath, max_lines=100):
              """Read file content safely, limiting lines for context"""
              try:
                  with open(filepath, 'r', encoding='utf-8') as f:
                      lines = f.readlines()
                      if len(lines) > max_lines:
                          return ''.join(lines[:max_lines]) + f'\n... (truncated, {len(lines)-max_lines} more lines)'
                      return ''.join(lines)
              except Exception as e:
                  return f"Error reading file: {str(e)}"
          
          def analyze_codebase():
              """Analyze the current codebase structure with size limits"""
              context = ""
              
              # Read project context (limited)
              if os.path.exists('project_context.txt'):
                  context += read_file_safely('project_context.txt', 30)
              
              # Read key configuration files (limited)
              key_files = ['package.json']  # Focus on most important file
              for file in key_files:
                  if os.path.exists(file):
                      context += f"\n\n=== {file} ===\n"
                      context += read_file_safely(file, 20)
              
              # Sample fewer source files to understand patterns
              if os.path.exists('codebase_files.txt'):
                  with open('codebase_files.txt', 'r') as f:
                      files = [line.strip() for line in f.readlines()[:3]]  # Only first 3 files
                  
                  for file in files:
                      if os.path.exists(file):
                          context += f"\n\n=== {file} ===\n"
                          context += read_file_safely(file, 10)  # Reduced lines
              
              # Limit total context size
              if len(context) > 5000:
                  context = context[:5000] + "\n... (context truncated for model limits)"
              
              return context
          
          def generate_code_with_claude(task_description, codebase_context):
              client = get_bedrock_client()
              
              prompt = f"""
          You are an expert software developer working on a React TypeScript application for web3 medical invoice storage.
          
          TASK: {task_description}
          
          CURRENT CODEBASE CONTEXT:
          {codebase_context}
          
          Please generate the necessary code changes to implement the requested feature. Your response should include:
          
          1. **FILES_TO_CREATE**: List any new files that need to be created with their full paths
          2. **FILES_TO_MODIFY**: List any existing files that need to be modified
          3. **CODE_CHANGES**: Provide the actual code for new files or specific changes for existing files
          4. **INSTRUCTIONS**: Any additional setup or configuration steps needed
          
          Follow these guidelines:
          - Use TypeScript and React hooks
          - Maintain consistency with existing code style
          - Include proper error handling
          - Add appropriate TypeScript types
          - Use existing utilities and patterns from the codebase
          - Focus on web3 integration and secure data handling
          
          Format your response clearly with sections for each file change.
          """
              
              # Try to use inference profile first, fallback to direct model ID
              model_id = os.environ.get('AWS_BEDROCK_MODEL_ID', 'anthropic.claude-3-sonnet-20240229-v1:0')
              
              body = {
                  "anthropic_version": "bedrock-2023-05-31",
                  "max_tokens": 8000,
                  "messages": [
                      {
                          "role": "user",
                          "content": prompt
                      }
                  ]
              }
              
              # Use only Claude Sonnet 4 as requested
              models_to_try = [
                  model_id,  # User configured model (Claude Sonnet 4)
                  'anthropic.claude-3-5-sonnet-20240620-v1:0',  # Claude 3.5 Sonnet
                  'anthropic.claude-3-sonnet-20240229-v1:0',  # Claude 3 Sonnet fallback
              ]
              
              response = None
              last_error = None
              
              for model_attempt in models_to_try:
                  if not model_attempt:  # Skip None/empty values
                      continue
                      
                  try:
                      print(f"Trying model: {model_attempt}")
                      
                      # For Amazon Titan, use different request format
                      if 'amazon.titan' in model_attempt:
                          titan_body = {
                              "inputText": prompt,
                              "textGenerationConfig": {
                                  "maxTokenCount": 8000,
                                  "stopSequences": [],
                                  "temperature": 0,
                                  "topP": 1
                              }
                          }
                          response = client.invoke_model(
                              body=json.dumps(titan_body),
                              modelId=model_attempt,
                              accept='application/json',
                              contentType='application/json'
                          )
                          # Parse Titan response differently
                          response_body = json.loads(response.get('body').read())
                          return response_body['results'][0]['outputText']
                      else:
                          # Claude models
                          response = client.invoke_model(
                              body=json.dumps(body),
                              modelId=model_attempt,
                              accept='application/json',
                              contentType='application/json'
                          )
                          response_body = json.loads(response.get('body').read())
                          return response_body['content'][0]['text']
                      
                  except Exception as e:
                      print(f"Model {model_attempt} failed: {str(e)[:100]}...")
                      last_error = e
                      continue
              
              # If all models failed, raise the last error
              raise Exception(f"All models failed. Last error: {last_error}")
          
          def create_branch_and_commit(branch_name, generated_content):
              """Create a new branch and commit the generated code"""
              try:

                  subprocess.run(['git', 'config', 'user.name', 'Claude Bot'], check=True)
                  subprocess.run(['git', 'config', 'user.email', 'claude-bot@example.com'], check=True)

                  # Create and checkout new branch
                  subprocess.run(['git', 'checkout', '-b', branch_name], check=True)
                  
                  # Create a summary file with the generated content
                  with open('CLAUDE_GENERATED.md', 'w') as f:
                      f.write(f"# Claude Generated Code\n\n")
                      f.write(f"**Task**: {os.environ['TASK_DESCRIPTION']}\n\n")
                      f.write(f"**Generated on**: {subprocess.check_output(['date']).decode().strip()}\n\n")
                      f.write("## Generated Content\n\n")
                      f.write("```\n")
                      f.write(generated_content)
                      f.write("\n```\n")
                  
                  # Stage and commit changes
                  subprocess.run(['git', 'add', '.'], check=True)
                  subprocess.run(['git', 'commit', '-m', f'Add Claude generated code\n\nTask: {os.environ["TASK_DESCRIPTION"]}\n\nGenerated by Claude AI via Amazon Bedrock'], check=True)
                  
                  # Push branch
                  subprocess.run(['git', 'push', '-u', 'origin', branch_name], check=True)
                  
                  return True
              except subprocess.CalledProcessError as e:
                  print(f"Git operation failed: {e}")
                  return False
          
          def create_pull_request(branch_name, task_description, generated_content):
              """Create a pull request with the generated code"""
              github_token = os.environ['GITHUB_TOKEN']
              repo = os.environ['GITHUB_REPOSITORY']
              
              headers = {
                  'Authorization': f'token {github_token}',
                  'Accept': 'application/vnd.github.v3+json'
              }
              
              pr_body = f"""## ğŸ¤– Claude AI Generated Code
          
          **Task Description:** {task_description}
          
          This pull request contains code generated by Claude AI via Amazon Bedrock based on the requested feature.
          
          ## Generated Changes
          
          ```
          {generated_content[:2000]}{'...' if len(generated_content) > 2000 else ''}
          ```
          
          ## Review Notes
          
          - Please review the generated code carefully
          - Test the functionality before merging
          - Make any necessary adjustments for your specific requirements
          - Check for integration with existing codebase
          
          ---
          *This PR was created automatically by Claude AI*
          """
              
              pr_data = {
                  'title': f'ğŸ¤– Claude Generated: {task_description[:50]}{"..." if len(task_description) > 50 else ""}',
                  'head': branch_name,
                  'base': 'main',
                  'body': pr_body
              }
              
              url = f'https://api.github.com/repos/{repo}/pulls'
              response = requests.post(url, headers=headers, json=pr_data)
              
              if response.status_code == 201:
                  pr_url = response.json()['html_url']
                  print(f"âœ… Pull request created: {pr_url}")
                  return pr_url
              else:
                  print(f"âŒ Failed to create PR: {response.status_code}")
                  print(response.text)
                  return None
          
          def main():
              task_description = os.environ['TASK_DESCRIPTION']
              branch_name = os.environ['TARGET_BRANCH']
              
              print(f"ğŸš€ Generating code for task: {task_description}")
              
              # Analyze codebase
              print("ğŸ“Š Analyzing codebase...")
              codebase_context = analyze_codebase()
              
              # Generate code with Claude
              print("ğŸ§  Generating code with Claude...")
              generated_content = generate_code_with_claude(task_description, codebase_context)
              
              # Create branch and commit
              print(f"ğŸŒ¿ Creating branch: {branch_name}")
              if create_branch_and_commit(branch_name, generated_content):
                  # Create pull request
                  print("ğŸ“ Creating pull request...")
                  pr_url = create_pull_request(branch_name, task_description, generated_content)
                  
                  if pr_url:
                      print(f"ğŸ‰ Code generation completed successfully!")
                      print(f"Pull request: {pr_url}")
                  else:
                      print("âš ï¸ Code generated but PR creation failed")
              else:
                  print("âŒ Failed to create branch and commit changes")
          
          if __name__ == "__main__":
              main()
          EOF
          
          python claude_generator.py
